---
title: 'Celtic Sea Program 4: FCube Forecasts'
author: "Paul J. Dolder, Marieke Desender, Claire Moore, Lionel Pawlowski"
output:
  html_document:
    df_print: paged
  pdf_document:
    fig_caption: yes
    fig_height: 6
    fig_width: 7
geometry: margin=1in
---  

```{r version control, message = FALSE, echo = FALSE, include = FALSE}

rm(list= ls())
gc()
ver1 <- "06_FigAdvice_Celtic_Sea_2020" # it was previously 2018
ver.datetime   <- date();
cat(paste("\n",ver1,"\n",sep=""));cat(paste(ver.datetime,"\n\n",sep=""))
start.time <- proc.time()[3]

```

Version:   *`r ver1`*

Runtime: *`r format(Sys.time(), '%d %B %Y %H:%M')`*


**Overview**

This document details the procedure used to run the FCube mixed fishery anaylsis forecasts.

In order to run this code (which is housed at the WGMIXFISH2 gitlab site [https://gitlab.com/WGMIXFISH/WGMIXFISH2]), you should have the following folder structure, which splits the data storage and code:

```
WGMIXFISH2
      |___functions
      |___Celtic_Sea
          |___program_rmd
          |   |___[This code here]
          |
          |__stocks
          |   |___ [working group stock objects here]
          |__results
          |   |___ [01_Reproduce_the_advice results here]
          |   |___ [03_Conditioning results here]
          |   |___ [04_FCube_forecast results here]
          |__plots
          |   |___ [single_species_advice.csv here]
          |__fleets  
              |___ [FLFleet here]
```

If you maintain this folder structure, no working directories need to be changed (just open this code in place).

```{r user setup, message=FALSE, warning=FALSE, tidy = TRUE}

options(stringsAsFactors = FALSE, scipen=100)

library(FLCore); library(FLash)
library(FLAssess); library(FLFleet)
library(pander); library(tables);
library(knitr); library(ggplot2)
library(dplyr); library(formatR)
library(grDevices);
library(tidyr)

 # additional functions
source("bootstrap/software/functions/FLFcube_FLCore_R31.R")
source("bootstrap/software/functions/remove_validity_FLFleet.R")
source("bootstrap/software/functions/funcs.R")



##-----------------------------------------------------------------------------
## I. GET INPUTS
##-----------------------------------------------------------------------------

load(file.path('results',"01_Reproduce_the_advice_Celtic_Sea_2020tier12nepnewLOUsingSAM.Rdata"))

load(file.path('results',"04_FCube_Forecasts_Celtic_Sea_2020tier12nepnewLOUsingSAMSQ_E_Catch_EffortByScenario.Rdata"))


## advice year
# from previous file
year<- Year + 1

## Landings obligation?
# read from previous file

#### variable to change if "basic run" or "new species" plot
Version<-"Basic_Run"

#### paths

###
type <- "SkipIntYr"
#SQ <- "TwoYear"

Data <- paste0("04_FCube_Forecasts_Celtic_Sea_2020tier12nepnewLOUsingSAM",type,"_Catch_EffortByScenario.RData")


### load outputs
load(paste(res.path,"/",Data,sep=''))

#results$sc[results$sc == "had.27.7b-k"] <- "had-cs"
#results$sc[results$sc == "whg.27.7b-ce-k"] <- "whg-cs"
results$sc[results$sc == "cod_fmsy"] <- "cod_FARMSY"

#adding optim
optim_ready <- TRUE 

if(optim_ready) {
load("results/Advice_sheet_resultsdiff2max-min_uncapped.Rdata")
optim <- as.data.frame(OptimAdvice)

#optim <- optim %>% gather(key = "value", value="data" , -stock,-sc, -year)
optim$sc <- "range"
#optim$year <- 2021

#optim <- optim %>% select(sc, year, stock, value, data)
results <- rbind(results, optim)
}


results$data <- as.numeric(results$data)
res.landings2<-results[which(results$value %in% c("landings", "Landings") & results$year==year),]
#res.landings2$sc[res.landings2$sc == "had.27.7b-k"] <- "had-cs"
#res.landings2$sc[res.landings2$sc == "whg.27.7b-ce-k"] <- "whg-cs"
#res.landings2$sc[res.landings2$sc == "meg.27.7b-k8abd"] <- "meg-cs"
#res.landings2$sc[res.landings2$sc == "mon.27.78abd"] <- "mon-cs"
#res.landings2$sc[res.landings2$sc == "sol.27.7fg"] <- "sol-cs"

#2019 quick fix
res.landings2<-res.landings2[,c("sc","stock","data")]
res.landings2<-reshape(res.landings2,direction='wide',idvar="stock",timevar="sc")
rownames(res.landings2)<-res.landings2$stock
res.landings3<-as.matrix(res.landings2[,-(1)])
colnames(res.landings3)<-unlist(strsplit(as.vector(colnames(res.landings3)),split="data."))[c((1:length(colnames(res.landings3)))*2)]

res.landings4<-t(res.landings3)

dem.names <- colnames(res.landings4)[!colnames(res.landings4) %in% grep("nep",colnames(res.landings4),value=T)]
yr.now     <-ac(year)
Advice_Approach<-""
###############################################################################################################################

#  plot with dem and NEP6-9 pulled
#  res. <- cbind(res.landings4,apply(res.landings4[,paste("NEP",6:9,sep="")],1,sum,na.rm=T))
#  colnames(res.)[length(colnames(res.))]<-"NEP6-9"
#  res. <- res.[,c(dem.names,"NEP6-9")]
res. <- res.landings4

##
res. <- cbind(res., "nep.27.7bk" = rowSums(res.[,nep.names]))
res. <- res.[,-c(7:12)]

scenarios <- c("min" ,"max" ,"sq_E", "val","had.27.7b-k","whg.27.7b-ce-k", "cod_fmsy", "range" )

# ADD TAC  order == COD HAD PleVIId PLEIV POK SolVIId SOLIV TUR WHG  NEP 6 to 9    !!!!
# TAC in advice year... # CM 2019: should this not be advise
  #*update annually*#
if(LO==TRUE) {
  # catches advice
  assign("TAC_cod.27.7e-k",0)
  assign("TAC_had.27.7b-k", 18382)
  assign("TAC_whg.27.7b-ce-k", 5261)            
  assign("TAC_meg.27.7b-k8abd", 19184)
  assign("TAC_mon.27.78abd", 34579)
  assign("TAC_sol.27.7fg", 1413)
  `TAC_nep.27.7bk` <-  7813
} else {
  # landings advice
  assign("TAC_cod.27.7e-k", 0)
  assign("TAC_had.27.7b-k", 9770)
  assign("TAC_whg.27.7b-ce-k", 4215)
  assign("TAC_meg.27.7b-k8abd", 16454)
  assign("TAC_mon.27.78abd", 33100)
  assign("TAC_sol.27.7fg", 1308)
  `TAC_nep.27.7bk` <-  7116
}

	res.<-rbind(res.,c(`TAC_cod.27.7e-k`,`TAC_had.27.7b-k`, `TAC_meg.27.7b-k8abd`,`TAC_mon.27.78abd`,`TAC_sol.27.7fg`,`TAC_whg.27.7b-ce-k`, `TAC_nep.27.7bk`))
	rownames(res.)[length(rownames(res.))]<-paste("TAC",year,sep='')

  res2 <- res.
  for (i in 1:dim(res2)[1]){
	for (j in 1:dim(res2)[2]) {
		res2[i,j]<-min(res2[i,j],res2[paste("TAC",year,sep=''),j])
	}
  }


##### test########
  res3 <- res.
  for (i in 2:dim(res3)[1]){
	for (j in 1:dim(res3)[2]) {
		res3[i,j]<-res3[i,j]-res3[paste("TAC",year,sep=''),j]
	}
  }
  res3[res3>0]<-0
#########################

scenarios <- unique(results$sc)
scenarios <- scenarios[!scenarios == grep("Reproduce", scenarios, value = T)]
scenarios <- scenarios[!scenarios == "range"]
#scenarios <- scenarios[!scenarios == "cod-cs"]

results$stock[results$stock %in% nep.names] <- "nep.27.7bk"

results <- results %>% group_by(sc, year, stock, value) %>%
	summarise(data = sum(data)) %>% as.data.frame()

write.csv(results,"results/data4advicefig.csv")

stocksToBePlotted <- unique(results$stock)
stocksToBePlotted <- c(stocksToBePlotted[-which(stocksToBePlotted == "nep.27.7bk")], "nep.27.7bk") ## put nephrops at end

# #jpeg('/plots/advice_sheet_figure.jpg')
png('plots/advice_sheet_figure.png', width = 400, height = 225, units='mm', res = 300)

layout(matrix(c(1,1,2,3), 2, 2),widths=c(3,1), heights=c(1,2))
par(mar=c(5.1,4.1,0, 2.1))
#pal <- c("#D62618", "darkslategray3", "darkolivegreen1", "antiquewhite3", "#FFC72C", "coral1", "aquamarine")
pal <- pals::brewer.paired(12)[1:length(stocksToBePlotted)]

res. <- res.[,stocksToBePlotted]
res2 <- res2[,stocksToBePlotted]
res3 <- res3[,stocksToBePlotted]

mp<-barplot(t(res.[row.names(res.)%in%scenarios,]),angle = 15, density = 20, col="black", beside = TRUE,legend = F
	            ,ylim=c(min(res3)+min(res3)*0.25,max(res.[row.names(res.)%in%scenarios,]+max(res.[row.names(res.)%in%scenarios,])*.25))
	            ,ylab=paste("predicted catch",yr.now), names.arg=rep('', length(scenarios)))
mp<-barplot(t(res2[row.names(res.)%in%scenarios,]), col=pal, beside = TRUE,legend = F
              ,ylim=c(min(res3)+min(res3)*0.25,(max(res.[row.names(res.)%in%scenarios,]+max(res.[row.names(res.)%in%scenarios,])*.25)))
              ,ylab=paste("predicted catch",yr.now), names.arg=rep('', length(scenarios)),add=T)
mp<-barplot(t(res3[row.names(res.)%in%scenarios,]), col=pal, beside = TRUE,legend = F, ylim=c(min(res3),0)
              ,ylab=paste("predicted catch",yr.now), names.arg=rep('', length(scenarios)),add=T)

mtext(side = 1, at =mp, line = 0.01,text = rep(formatC(c(1:dim(res.)[2])),5), col = "black",cex=1)
text(0,max(res.[row.names(res.)%in%scenarios,]+max(res.[row.names(res.)%in%scenarios,])*.2),pos=1) #"Scenarios: ",
for (i in 1:length(scenarios)){
  	text((i-1)*(dim(res.)[2]+1)+.3,max(res.[row.names(res.)%in%scenarios,]+max(res.[row.names(res.)%in%scenarios,])*.15), scenarios[i], pos=4,cex=1.2 )
}
mtext(side = 2, at =min(res3)*.8, line = 3,text = "undershoot", col = "black",cex=1)
abline(h=0, col="black")
for(i in 1:dim(res.)[2]){
		# abline(h=res.[paste("TAC",year,sep=''),colnames(res.)[i]], col="black",lty=2) # black hlines
    abline(h=res.[paste("TAC",year,sep=''),colnames(res.)[i]], col=pal[i],lty=2) # coloured hlines
}

for(i in 1:dim(res.)[2]){
	mtext(side=4,at=res.[paste("TAC",year,sep=''),i],text=i, cex=1,las=2) # black numbers
  # mtext(side=4,at=res.[paste("TAC",year,sep=''),i],text=i, col=pal[i], cex=1,las=2) # coloured numbers
}

for(i in 1:length(scenarios)){
	rect((i-1)*(dim(res.)[2]+1)+0.7,min(res3)+min(res3)*0.25,i*(dim(res.)[2]+1)+.2,max(res.[scenarios,])+max(res.[scenarios,])*.25, lty=1)
}

par(mar=c(3,1,0, 2.1))
plot(c(0,0), col="white",  axes=F, xlab="", ylab="")
plot(c(0,0), col="white",  axes=F, xlab="", ylab="")
legend("bottom",fill=pal,cex=1.2,bty='n',
legend= paste(c(1:length(stocksToBePlotted)), stocksToBePlotted, sep=':'),ncol=1)

dev.off()
```
