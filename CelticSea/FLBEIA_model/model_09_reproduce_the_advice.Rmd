---
title: "Celtic Sea FLBEIA short-term forecast model"
author: "Paul J. Dolder and Claire Moore"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
rm(list = ls())
library(FLBEIA)
library(tidyverse)
library(knitr)
library(huxtable)
opts_chunk$set(echo = TRUE, 
               tidy = TRUE,
               comment = "#>")
```

## Model setup
## ~ Main control object
Here we set out the bounds of our forecasts. 
```{r Main_ctrl}
first.yr.sim <- 2020
last.yr.sim  <- 2022
main.ctrl <- list()
main.ctrl$sim.years <-c(initial = first.yr.sim, final = last.yr.sim)
main.ctrl$SimultaneousMngt <- FALSE ## Note, this relates to the multi-stock HCR
```


## ~ Load Fleet and Biol objects
We take some short-cuts, in that the FLFleetExt and FLBiol objects are already converted from FLFLeets and FLStocks objects created for FCube. The code is available elsewhere for this as its a bit tedious. 
Loading in the fleet and biols objects. Note that its important the FLFleets object has the same sum catches as the FLBiols object....

```{r load_objs}
stock_path <- file.path("results", "clean_data", "clean_stock_objects")

## Convert to FLBiols
source(file.path("bootstrap", "software", "functions", "make_FLBiols.R"))
source(file.path("bootstrap", "software", "functions", "FLStock_to_FLFleet.R"))
biols <- make_FLBiols(stock_path)
fleets   <- make_simple_FLFleet(stock_path) 
## Remove the stocks not in model
stock.list <- c("cod.27.7e-k",  "had.27.7b-k","whg.27.7b-ce-k", "hke.27.3a46-8abd", "meg.27.7b-k8abd", "mon.27.78abd", "sol.27.7fg")
#,  "nep.fu.16","nep.fu.17", "nep.fu.19", "nep.fu.2021", 		 "nep.fu.22", "nep.out.7" )

biols <- biols[names(biols) %in% stock.list]
fleets <- fleets[names(fleets) %in% stock.list]

```

## ~ Expand the FLFleetExt and FLBiol object

```{r}
## Expand the biols to simulation years
data.yrs <- c(range(biols)[["minyear"]], range(biols)[["maxyear"]])
biols <- lapply(biols, window, start = data.yrs[1] , end = last.yr.sim)
stks <- sort(names(biols))
fleets<-FLFleetsExt(lapply(fleets,window,data.yrs[1],last.yr.sim)) 

summary(biols)
summary(fleets)
```


## ~ Condition the FLBiol object

Here we condition the biol/stock objects for the simulation. This includes the mean weights, maturity and natural mortality for each age.


```{r biol_cond}

# Now fill the slots in projection years for FLBiols
## Note, we will want to do specifically for each stock and this is a short-cut

stk.avg.yrs <- 2017:2019

# I think we need to set this here
biols<-FLBiols(lapply(names(biols),function(x) {
  s<-biols[[x]]
  s@m[,ac(first.yr.sim:last.yr.sim)]<-yearMeans(s@m[,ac(stk.avg.yrs)])
  s@wt[,ac(first.yr.sim:last.yr.sim)]<-yearMeans(s@wt[,ac(stk.avg.yrs)])
  
  mat(s)[,ac(first.yr.sim:last.yr.sim)]<-yearMeans(s@mat$mat[,ac(stk.avg.yrs)])
  fec(s)[,ac(first.yr.sim:last.yr.sim)]<-yearMeans(s@fec$fec[,ac(stk.avg.yrs)])
  s@spwn <- s@n # I think this is wrong 
  s@spwn[] <- 0 # why is this set to zero
  
  return(s)
}))

```

## ~ Fleet conditioning

Here we condition the FLFleetsExt for the simulation. We assume a simple average of values in the projection years, but in principle its possible to make this particular for a fleet or parameter. We recalculate the catchabilities for the fleet-metier-stock combinations to ensure they are consistent; we have assumed that alpha and beta are 1 for the simulations, though these can be estimated from the historic data by fleet-metier-stock.

Note:: We may want here to split the OTH_OTH fleet into a series of fleets, one for each stock, e.g. OTH_COD, OTH_HKE etc...

NOTE: We have also included a flag to load an already conditioned fleet, as it take a long time....

```{r fleet_yrs}
Cond_Fleet <- TRUE 

fl.proj.avg.yrs <- 2017:2019 ## weights including landings.wt, discards.wt
sel.yrs <- 2017:2019 ## the selection pattern including effort, effshare, catch.q, landings.sel, discards.sel
```

```{r fleet_cond, results = 'hide'}
if(Cond_Fleet) {
  
nms.fls <- names(fleets)
l.fls   <- length(nms.fls)

for(i in 1:l.fls){
  print(nms.fls[i])
  
  nms.metiers <- names(fleets[[i]]@metiers)
  l.metiers   <- length(nms.metiers)
  
  fleets[[i]]@effort[, ac(first.yr.sim:last.yr.sim)]    <- yearMeans(fleets[[i]]@effort[, ac(sel.yrs)])
  fleets[[i]]@fcost[, ac(first.yr.sim:last.yr.sim)]     <- yearMeans(fleets[[i]]@fcost[, ac(fl.proj.avg.yrs)])
  fleets[[i]]@capacity[, ac(first.yr.sim:last.yr.sim)]  <- yearMeans(fleets[[i]]@capacity[, ac(fl.proj.avg.yrs)])
  fleets[[i]]@crewshare[, ac(first.yr.sim:last.yr.sim)] <- yearMeans(fleets[[i]]@crewshare[, ac(fl.proj.avg.yrs)])
  
  for( j in 1:l.metiers){
    fleets[[i]]@metiers[[j]]@effshare[, ac(first.yr.sim:last.yr.sim)] <- yearMeans(fleets[[i]][[j]]@effshare[, ac(sel.yrs)] )
    fleets[[i]]@metiers[[j]]@vcost[, ac(first.yr.sim:last.yr.sim)]    <- yearMeans(fleets[[i]][[j]]@vcost[, ac(fl.proj.avg.yrs)])
    
    nms.stks <- names(fleets[[nms.fls[i]]]@metiers[[nms.metiers[j]]]@catches)
    l.stks <- length(nms.stks)
    
    for( k in 1:l.stks){
      
      ## Normally the weights are average of 3 years while the selection is the rescaled F,
      ## but we need to be stock specific
      
      if(nms.stks[k] %in% c("HAD")) { 
        
      fleets[[i]]@metiers[[j]]@catches[[k]]@landings.wt[, ac(first.yr.sim:last.yr.sim)]  <- yearMeans(fleets[[i]]@metiers[[j]]@catches[[k]]@landings.wt[,ac(fl.proj.avg.yrs)])
      fleets[[i]]@metiers[[j]]@catches[[k]]@discards.wt[, ac(first.yr.sim:last.yr.sim)]  <- yearMeans(fleets[[i]]@metiers[[j]]@catches[[k]]@discards.wt[,ac(fl.proj.avg.yrs)])
        
        } else {
      
      fleets[[i]]@metiers[[j]]@catches[[k]]@landings.wt[, ac(first.yr.sim:last.yr.sim)]  <- yearMeans(fleets[[i]]@metiers[[j]]@catches[[k]]@landings.wt[,ac(fl.proj.avg.yrs)])
      fleets[[i]]@metiers[[j]]@catches[[k]]@discards.wt[, ac(first.yr.sim:last.yr.sim)]  <- yearMeans(fleets[[i]]@metiers[[j]]@catches[[k]]@discards.wt[,ac(fl.proj.avg.yrs)])
      
      }
      
      ## selection 
      fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[, ac(first.yr.sim:last.yr.sim)] <- yearMeans(fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[,ac(sel.yrs)])
  
      # set any NAs in the proj year to 0 (in case of no catch)
      fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[, ac(first.yr.sim:last.yr.sim)][is.na(fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[, ac(first.yr.sim:last.yr.sim)])]<-0
      # discards selectivity as the inverse of the landings sel
      fleets[[i]]@metiers[[j]]@catches[[k]]@discards.sel[, ac(first.yr.sim:last.yr.sim)] <- 1-fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[, ac(first.yr.sim:last.yr.sim)]
       fleets[[i]]@metiers[[j]]@catches[[k]]@catch.q[,ac(first.yr.sim:last.yr.sim) ]     <- yearMeans(fleets[[i]]@metiers[[j]]@catches[[k]]@catch.q[,ac(sel.yrs)])
      fleets[[i]]@metiers[[j]]@catches[[k]]@catch.q[, ac(first.yr.sim:last.yr.sim)][is.na(fleets[[i]]@metiers[[j]]@catches[[k]]@catch.q[, ac(first.yr.sim:last.yr.sim)])]<-0     
     
      # Catch prod values 
      fleets[[i]]@metiers[[j]]@catches[[k]]@alpha[, ac(first.yr.sim:last.yr.sim)]        <- yearMeans(fleets[[i]]@metiers[[j]]@catches[[k]]@alpha[,ac(fl.proj.avg.yrs)])
      fleets[[i]]@metiers[[j]]@catches[[k]]@beta[, ac(first.yr.sim:last.yr.sim)]         <- yearMeans(fleets[[i]]@metiers[[j]]@catches[[k]]@beta[,ac(fl.proj.avg.yrs)])
      

      fleets[[i]]@metiers[[j]]@catches[[k]]@price[, ac(first.yr.sim:last.yr.sim)]  <- yearMeans(fleets[[i]]@metiers[[j]]@catches[[k]]@price[,ac(fl.proj.avg.yrs)])
      
    }
  }
}

fleets <- FLFleetsExt(fleets)

} 
```

## ~ Stock-Recruit

Here we set up the recruitment parameters for the short-term forecasts. As with FCube, we use the values from the single stock assessment, but here we do this in the form of an FLSRsim object - using a geomean model with the parameters set to the values in the single stock assessment.

For the *Nephrops* stock (or any fixed biomass stock) we would create a dummy FLSRsim object with an arbitrary large value.

```{r SR}
## Empty FLQuant with the right dimensions
flq_dims <- FLQuant(1, dim = c(1, length(data.yrs[1]:last.yr.sim)), dimnames = list(quant = 'all', year = data.yrs[1]:last.yr.sim))

## For each ASPG stock, fill the recruitment used in the single stock assessment forecast
COD.sr <- FLSRsim(rec = biols[["cod.27.7e-k"]]@n[1,], ssb = ssb(biols[["cod.27.7e-k"]]), 
                uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "cod.27.7e-k")
COD.sr@params[] <- 1640 # this value comes form table 2 on the advice sheet

HAD.sr <- FLSRsim(rec = biols[["had.27.7b-k"]]@n[1,], ssb = ssb(biols[["had.27.7b-k"]]),
                  uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "had.27.7b-k")
  HAD.sr@params[] <- 351066
  
WHG.sr <- FLSRsim(rec = biols[["whg.27.7b-ce-k"]]@n[1,], ssb = ssb(biols[["whg.27.7b-ce-k"]]),
                 uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "whg.27.7b-ce-k")
WHG.sr@params[] <- 568878

HKE.sr <- FLSRsim(rec = biols[["hke.27.3a46-8abd"]]@n[1,], ssb =ssb(biols[["hke.27.3a46-8abd"]]), uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "hke.27.3a46-8abd")
HKE.sr@params[] <- 308019

MEG.sr <- FLSRsim(rec = biols[["meg.27.7b-k8abd"]]@n[1,], ssb =ssb(biols[["meg.27.7b-k8abd"]]), uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "meg.27.7b-k8abd")
MEG.sr@params[] <- 223393
 
 MON.sr <- FLSRsim(rec = biols[["mon.27.78abd"]]@n[1,], ssb =ssb(biols[["mon.27.78abd"]]), uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "mon.27.78abd")
 MON.sr@params[] <- 32000

SOL.sr <- FLSRsim(rec = biols[["sol.27.7fg"]]@n[1,], ssb = ssb(biols[["sol.27.7fg"]]),
                  uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "sol.27.7fg")
 SOL.sr@params[] <- 5187
      

# NEP.16.sr <- FLSRsim(rec = biols[["nep.fu.16" ]]@n[1,], ssb = ssb(biols[["nep.fu.16" ]]),     uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "nep.fu.16" )
# NEP.16.sr@params[] <- 1000000
# 
# NEP.17.sr <- FLSRsim(rec = biols[["nep.fu.17" ]]@n[1,], ssb = ssb(biols[["nep.fu.17" ]]),     uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "nep.fu.17" )
# NEP.17.sr@params[] <- 1000000
# 
# NEP.19.sr <- FLSRsim(rec = biols[["nep.fu.19" ]]@n[1,], ssb = ssb(biols[["nep.fu.19" ]]),     uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "nep.fu.19" )
# NEP.19.sr@params[] <- 1000000
# 
# NEP.2021.sr <- FLSRsim(rec = biols[["nep.fu.2021"  ]]@n[1,], ssb = ssb(biols[["nep.fu.2021"  ]]),     uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "nep.fu.2021"  )
# NEP.2021.sr@params[] <- 1000000
# 
# NEP.22.sr <- FLSRsim(rec = biols[["nep.fu.22"  ]]@n[1,], ssb = ssb(biols[["nep.fu.22" ]]),     uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "nep.fu.22"  )
# NEP.22.sr@params[] <- 1000000
# 
# NEP.OUT.7.sr <- FLSRsim(rec = biols[["nep.out.7" ]]@n[1,], ssb = ssb(biols[["nep.out.7" ]]),     uncertainty = flq_dims, proportion = flq_dims, model = 'geomean', name = "nep.out.7" )
# NEP.OUT.7.sr@params[] <- 1000000
# 
SRs <- list(`cod.27.7e-k` = COD.sr, `had.27.7b-k` = HAD.sr, `whg.27.7b-ce-k` = WHG.sr,`hke.27.3a46-8abd` = HKE.sr  , `meg.27.7b-k8abd` = MEG.sr, `mon.27.78abd` = MON.sr, `sol.27.7fg` = SOL.sr )
            
            #, `nep.fu.16` = NEP.16.sr, `nep.fu.17` = NEP.17.sr,  `nep.fu.19`= NEP.19.sr, `nep.fu.19`= NEP.19.sr, `nep.fu.2021`= NEP.2021.sr, `nep.fu.22`= NEP.22.sr, `nep.out.7`= NEP.OUT.7.sr)
#  
range(SRs[[1]])[4] <- 1980
range(SRs[[1]])[5] <- 2022
```


## ~ Biols Control

Here we fix the type of growth model for each stock. Normally this would be ASPG (Age-structured population growth), though BDPG (biomass dynamic) and fixedPopulation are also available. We use the latter for the *Nephrops* stocks.

```{r biols_ctrl}
Baranov          <- rep(FALSE,length(stock.list) )

growth.model     <- ifelse(!Baranov, c(`cod.27.7e-k`='ASPG', `had.27.7b-k`='ASPG', `whg.27.7b-ce-k`='ASPG', `hke.27.3a46-8abd` ='ASPG', `meg.27.7b-k8abd`='ASPG', `mon.27.78abd`='ASPG', `sol.27.7fg`='ASPG'),   c(`cod.27.7e-k` = "ASPG_Baranov", `had.27.7b-k` = "ASPG_Baranov", `whg.27.7b-ce-k` = "ASPG_Baranov", `hke.27.3a46-8abd` = "ASPG_Baranov",`meg.27.7b-k8abd` = "ASPG_Baranov",  `meg.27.7b-k8abd` = "ASPG_Baranov", `mon.27.78abd` = "ASPG_Baranov", `sol.27.7fg` = "ASPG_Baranov")) ; names(growth.model) <- 
  c("cod.27.7e-k", "had.27.7b-k", "whg.27.7b-ce-k", "hke.27.3a46-8abd", "meg.27.7b-k8abd", "mon.27.78abd", "sol.27.7fg")

#, `nep.fu.16` = "fixedPopulation" , `nep.fu.17` = "fixedPopulation" , `nep.fu.19` = "fixedPopulation" , `nep.fu.2021` = "fixedPopulation" , `nep.fu.22` = "fixedPopulation" , `nep.out.7` =  "fixedPopulation"
#, `nep.fu.16` = "fixedPopulation" , `nep.fu.17` = "fixedPopulation" , `nep.fu.19` = "fixedPopulation" , `nep.fu.2021` = "fixedPopulation" , `nep.fu.22` = "fixedPopulation" , `nep.out.7` =  "fixedPopulation"
#, "nep.fu.16" , "nep.fu.17", "nep.fu.19" , "nep.fu.2021" ,"nep.fu.22" , "nep.out.7" 

growth.model <- growth.model[sort(names(growth.model))]
biols.ctrl   <- create.biols.ctrl(stksnames=stks,growth.models=growth.model)
```


## ~ Advice controls

Here we set two elements which are not used in a short-term forecast: firstly, there is no **observation model** so each stock is set to *'perfectObs'*; secondly there is no **assessment model** so each stock is set accordingly (*NoAssessment*).

For the **advice model**, we want to specify the TACs for the stocks rather than a specific HCR. Therefore the HCR is *fixedAdvice*, which we set to be on the basis of 'catch' rather than 'landings'. 

```{r controls, echo= TRUE}

## Obs ctrl - as a STF, we assume perfect obs
stkObs.models<-rep('perfectObs',length(stks)) ; names(stkObs.models)<-stks
obs.ctrl  <- create.obs.ctrl(stksnames = stks,  stkObs.models = stkObs.models)

obs.ctrl <- obs.ctrl[sort(names(obs.ctrl))]

## assess ctrl - as a STF, we do not do an assessment 

assess.models<-rep('NoAssessment',length(stks)); names(assess.models)<-stks
assess.ctrl<-create.assess.ctrl(stksnames=stks,assess.models=assess.models)

assess.ctrl <- assess.ctrl[sort(names(assess.ctrl))]

################
## advice ctrl
################

## We use the actual TAC advice
advice.ctrl <- create.advice.ctrl(stksnames = stks, HCR.models = rep('fixedAdvice', length(stks)))

# advice based on catch, not landings
for (i in stock.list){
  advice.ctrl[[i]]$AdvCatch<- TRUE 
  }
  
```

## ~ TAC advice

Here we specify the actual **TAC advice** for each stock in both the *intermediate* and the *TAC* years. We also specify our assumption of the future quota share across fleets, which here is set to the same average years as the rest of the fleet parameters.


```{r TACs}
advice <- list(TAC = FLQuant(NA, dimnames = list(stocks = stks, year = data.yrs[1]:last.yr.sim)),
               quota.share = lapply(stks, function(x) {
                 FLQuant(NA,
                         dimnames = list(fleets = names(fleets), year = data.yrs[1]:last.yr.sim))
               }))

## Catch from Table 2 in for intermediate and ICES headline advice for advice year 
 
advice$TAC['cod.27.7e-k', ac(2020:2022)] <- c(1055, rep(0, 2)) #lan 805 + 250
advice$TAC['had.27.7b-k', ac(2020:2022)] <- c(20274, rep(18382, 2))
advice$TAC['whg.27.7b-ce-k', ac(2020:2022)] <- c(8772, rep(5261, 2))
advice$TAC['hke.27.3a46-8abd', ac(2020:2022)] <- c(103027, rep(98657, 2))
advice$TAC['meg.27.7b-k8abd', ac(2020:2022)] <- c(20350, rep(19184, 2))
advice$TAC['mon.27.78abd', ac(2020:2022)] <- c(24343, rep(34579, 2))
advice$TAC['sol.27.7fg', ac(2020:2022)] <- c(1652, rep(1413, 2))

# advice$TAC['nep.fu.16', ac(2020:2022)] <- c(2637, rep(3290, 2))
# advice$TAC['nep.fu.17', ac(2020:2022)] <- c(800, rep(508, 2))
# advice$TAC['nep.fu.19', ac(2020:2022)] <- c(839, rep(595, 2))
# advice$TAC['nep.fu.2021', ac(2020:2022)] <- c(1150, rep(1710, 2))
# advice$TAC['nep.fu.22', ac(2020:2022)] <- c(2820, rep(1560, 2))
# advice$TAC['nep.out.7', ac(2020:2022)] <- c(188, rep(150, 2)) # NEP values taken from predicted catch 

kable(reshape2::dcast(as.data.frame(advice$TAC[,ac(2020:2022)]), stocks ~ year, value.var = "data"), caption = "TAC advice in intermediate and TAC year")

names(advice$quota.share) <- stks

for(st in stks){
  for(fl in names(fleets)) {
    if(st %in% catchNames(fleets[[fl]])){
      advice$quota.share[[st]][fl,] <- quantSums(catchWStock.f(fleets[[fl]], st))/
                                       quantSums(catchWStock(fleets, st))
      advice$quota.share[[st]][fl, ac(data.yrs[1]:last.yr.sim)] <-
        yearMeans(advice$quota.share[[st]][fl, ac(sel.yrs)])  ## change to sel.yrs
    } else
      advice$quota.share[[st]][fl,] <- 0
      
    }
  }
```


## ~ Fleets controls

Here we set up a simple fleets control object. We will use this as a template for the mixed fisheries scenarios. It includes:

* The **fleet model**: to match FCube we used *'fixedEffort'* and *SMFB* (simple mixed fisheries behaviour) with an appropriate catch rule (min, max or stock). But here we just set up a template which we will alter later dependent on the scenario.
* We define a *catch restriction*, i.e. landings or catch.
* We define the *catch model* per stock. These should match the biol model, i.e . CobbDouglasAge or CobDouglasBio
* There are other features which we could use here. For example, the *landing obligation* including de minimis and other rules.

* Other features such as captial and price models can also be configured. However, these have additional data requirements which enter in the Covars,


```{r fleets_ctrl}

LO <- FALSE 

fls   <-names(fleets)
n.fls <-length(fleets) #number of the fleets

n.stks<-sum(sapply(sapply(fleets, catchNames), length)) # number of the fleet/stocks
n.flts.stks      <- sapply(lapply(fleets, catchNames), length) # number of stocks caught by each fleet.
flts.stksnames   <- NULL; for(f in 1:length(fleets))  flts.stksnames <- c(flts.stksnames, catchNames(fleets[[f]])) 


#### FLEET MODELS
## Fixed effort, SMFB etc...
## SMFB, min equivilent to FCube min 
effort.models    <- rep("SMFB",n.fls) ; names(effort.models)<-fls
#eff.res <- "min"
## using SMFB set the effort limitation by fleet, i.e. vector with n.fl values with min, max etc..
## using SMFB, set a restriction on 'catch' or 'landings' by fleet
restriction  <- rep("catch",n.fls) ; names(restriction) <-fls 

### CATCH MODELS
## Can change for each fleet/stock
c.mod<-stack(lapply(fleets,catchNames))
c.mod$catch.mod<-sapply(c.mod$values,function(x) {
  if(x %in% c("cod.27.7e-k", "had.27.7b-k", "whg.27.7b-ce-k","hke.27.3a46-8abd", "meg.27.7b-k8abd", "mon.27.78abd",  "sol.27.7fg", "nep.fu.16" , "nep.fu.17","nep.fu.19" , "nep.fu.2021" , "nep.fu.22","nep.out.7")) return("CobbDouglasAge") else
  return("CobbDouglasBio")
})
catch.models     <- c.mod$catch.mod ; names(catch.models)<-paste(c.mod$ind,c.mod$values,sep=".")

### CAPTIAL MODELS
## Options are:
capital.models   <- rep("fixedCapital",n.fls)           ; names(capital.models)<-fls

### PRICE MODELS
## Options are:
price.models     <- rep("fixedPrice",n.stks)            ; names(price.models)<-paste(c.mod$ind,c.mod$values,sep=".")


flq   <- FLQuant(dimnames = list(quant = 'all', year = data.yrs[1]:last.yr.sim, season = 1), iter = 1)

fleets.ctrl      <- create.fleets.ctrl(fls = fls,n.fls.stks=n.flts.stks,fls.stksnames=flts.stksnames,
                                         effort.models= effort.models,catch.models=catch.models,
                                         capital.models=capital.models, price.models=price.models,flq=flq)


if(LO) { 
  for (f in names(fleets)) { 
    #f = "cod.27.7e-k" 
      fleets.ctrl[[f]]$LandObl <- c(rep(FALSE, length(data.yrs[1]:data.yrs[2])), rep(TRUE,length(first.yr.sim:last.yr.sim)) )  
    names(fleets.ctrl[[f]]$LandObl) <- c(data.yrs[1]:last.yr.sim)
    
    fleets.ctrl[[f]]$LandObl_minimis <- c(rep(FALSE, length(data.yrs[1]:last.yr.sim)) )
    names(fleets.ctrl[[f]]$LandObl_minimis) <- c(data.yrs[1]:last.yr.sim)
    
    fleets.ctrl[[f]]$LandObl_minimis_p <- matrix(0, nrow = length(catchNames(fleets[[f]])), ncol = length(data.yrs[1]:last.yr.sim),
                                                      dimnames = list(sort(catchNames(fleets[[f]])), c(data.yrs[1]:last.yr.sim)))
    
    fleets.ctrl[[f]]$LandObl_yearTransfer <- c(rep(FALSE, length(data.yrs[1]:last.yr.sim)))
    names(fleets.ctrl[[f]]$LandObl_yearTransfer) <- c(data.yrs[1]:last.yr.sim)
    
    fleets.ctrl[[f]]$LandObl_yearTransfer_p <- matrix(0, nrow = length(catchNames(fleets[[f]])), ncol = length(data.yrs[1]:last.yr.sim),
                                                      dimnames = list(sort(catchNames(fleets[[f]])), c(data.yrs[1]:last.yr.sim)))
    
    fleets.ctrl[[f]]$LandObl_discount_yrtransfer <- array(0, dim = c(length(catchNames(fleets[[f]])),length(data.yrs[1]:last.yr.sim),1),
                                                          dimnames = list(sort(catchNames(fleets[[f]])), c(data.yrs[1]:last.yr.sim), 1))
  }
  }


## Recalculate the catchability for the projection years - uses either CobbDouglas or Baranov
fleets <- calculate.q.sel.flrObjs(biols, fleets, NULL, fleets.ctrl, sel.yrs, first.yr.sim:last.yr.sim)

## loop
l.fls   <- length(fleets)#
nms.fls <- names(fleets)


for(i in 1:l.fls){
  print(nms.fls[i])
  
  nms.metiers <- names(fleets[[i]]@metiers)
  l.metiers   <- length(nms.metiers)
  
  for( j in 1:l.metiers){
    nms.stks <- names(fleets[[nms.fls[i]]]@metiers[[nms.metiers[j]]]@catches)
    l.stks <- length(nms.stks)
    
   for( k in 1:l.stks){
     
      ## weight
           if(fleets[[i]]@metiers[[j]]@catches[[k]]@name == "WHG") {
           fleets[[i]]@metiers[[j]]@catches[[k]]@landings.wt[, ac(first.yr.sim:last.yr.sim)] <- whg.lwt
           fleets[[i]]@metiers[[j]]@catches[[k]]@discards.wt[, ac(first.yr.sim:last.yr.sim)] <- whg.dwt
           }
      
      ## selection 
      if(fleets[[i]]@metiers[[j]]@catches[[k]]@name == "HAD") {
       fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[, ac(first.yr.sim:last.yr.sim)] <- fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[, ac(first.yr.sim:last.yr.sim)]
      } else {
     fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[, ac(first.yr.sim:last.yr.sim)] <- yearMeans(fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[,ac(sel.yrs)])
      }
     
      # set any NAs in the proj year to 0 (in case of no catch)
      fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[, ac(first.yr.sim:last.yr.sim)][is.na(fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[, ac(first.yr.sim:last.yr.sim)])]<-0
      # discards selectivity as the inverse of the landings sel
      fleets[[i]]@metiers[[j]]@catches[[k]]@discards.sel[, ac(first.yr.sim:last.yr.sim)] <- 1-fleets[[i]]@metiers[[j]]@catches[[k]]@landings.sel[, ac(first.yr.sim:last.yr.sim)]
      
      fl <- i
      mt <- j
      st <- nms.stks[k] 
      
      ## recalculate the catchability
      B <- biols[[st]]@n * exp(-biols[[st]]@m/2)
     C <- (fleets[[fl]]@metiers[[mt]]@catches[[st]]@discards.n + 
                  fleets[[fl]]@metiers[[mt]]@catches[[st]]@landings.n)
                alpha <- fleets[[fl]]@metiers[[mt]]@catches[[st]]@alpha
                beta <- fleets[[fl]]@metiers[[mt]]@catches[[st]]@beta
                E <- fleets[[fl]]@effort * fleets[[fl]]@metiers[[mt]]@effshare
                
                  fleets[[fl]]@metiers[[mt]]@catches[[st]]@catch.q <- C/((E %^% 
                    alpha) * (B %^% beta))
                  
    ## and the means for sim years
    fleets[[fl]]@metiers[[mt]]@catches[[st]]@catch.q[,ac(first.yr.sim:last.yr.sim)] <- 
      apply(fleets[[fl]]@metiers[[mt]]@catches[[st]]@catch.q[,ac(sel.yrs)],1,mean)
                
    }
  }
}

## For whiting, let's check the catch weights are right, as per the reproduce the advice
fleets <- FLFleetsExt(fleets)

## All others are already set to SMFB effort.model, so we just need to modify the
## option
fleets.ctrl.cod <- fleets.ctrl
fleets.ctrl.cod.int <- fleets.ctrl
fleets.ctrl.had <- fleets.ctrl
fleets.ctrl.whg <- fleets.ctrl
fleets.ctrl.hke <- fleets.ctrl
fleets.ctrl.meg <- fleets.ctrl
fleets.ctrl.mon <- fleets.ctrl
fleets.ctrl.sol <- fleets.ctrl
# fleets.ctrl.nep16 <- fleets.ctrl
# fleets.ctrl.nep17<- fleets.ctrl
# fleets.ctrl.nep19 <- fleets.ctrl
# fleets.ctrl.nep2021 <- fleets.ctrl
# fleets.ctrl.nep22 <- fleets.ctrl
# fleets.ctrl.nepout7 <- fleets.ctrl

for (fl in names(fleets)) {
    fleets.ctrl.cod[[fl]][["effort.restr"]] <- "cod.27.7e-k"
}

for (fl in names(fleets)) {
    fleets.ctrl.cod.int[[fl]][["effort.model"]] <- "fixedEffort"
}

for (fl in names(fleets)) {
    fleets.ctrl.had[[fl]][["effort.restr"]] <- "had.27.7b-k"
}
for (fl in names(fleets)) {
    fleets.ctrl.whg[[fl]][["effort.restr"]] <- "whg.27.7b-ce-k"
}

for (fl in names(fleets)) {
    fleets.ctrl.hke[[fl]][["effort.restr"]] <-  "hke.27.3a46-8abd"
}

for (fl in names(fleets)) {
    fleets.ctrl.meg[[fl]][["effort.restr"]] <- "meg.27.7b-k8abd"
}
for (fl in names(fleets)) {
    fleets.ctrl.mon[[fl]][["effort.restr"]] <- "mon.27.78abd"
}
for (fl in names(fleets)) {
    fleets.ctrl.sol[[fl]][["effort.restr"]] <- "sol.27.7fg"
}
# for (fl in names(fleets)) {
#     fleets.ctrl.nep16[[fl]][["effort.restr"]] <- "nep.fu.16"
# }
# 
# for (fl in names(fleets)) {
#     fleets.ctrl.nep17[[fl]][["effort.restr"]] <- "nep.fu.17" 
# }
# 
# for (fl in names(fleets)) {
#     fleets.ctrl.nep19[[fl]][["effort.restr"]] <- "nep.fu.19" 
# }
# 
# for (fl in names(fleets)) {
#     fleets.ctrl.nep2021[[fl]][["effort.restr"]] <- "nep.fu.2021"
# }
# 
# for (fl in names(fleets)) {
#     fleets.ctrl.nep22[[fl]][["effort.restr"]] <- "nep.fu.22" 
# }
# 
# for (fl in names(fleets)) {
#     fleets.ctrl.nepout7[[fl]][["effort.restr"]] <- "nep.out.7"   
# }

for(fl in names(fleets)) { fleets[[fl]]@capacity[] <- 1e12} # ensure not cap limited

# Fix to resolve some missing NA's
fleets$`had.27.7b-k`@metiers$`had.27.7b-k`@catches$`had.27.7b-k`@catch.q[1] <- 1e-12

```

## Reproduce the advice 
## ~ COD
```{r}
  runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.cod,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_cod <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_cod["F",] <- c(1.13, 0.477, 0,NA)
ss_cod["SSB",] <- c(1181, 1587, 2943,6078)
ss_cod["catches",] <- c(1351,1055, NA,NA)
ss_cod["landings",] <- c(1051, 0, NA,NA)
ss_cod["discards",] <- c(300, 0, NA,NA)

cod.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
cod.fb <- cod.flbeia %>% filter(stock == "cod.27.7e-k")
fb_cod <- data.frame("F" = cod.fb$value[cod.fb$indicator == "f"],"SSB" = cod.fb$value[cod.fb$indicator == "ssb"], "catches" = cod.fb$value[cod.fb$indicator == "catch"], "landings" = cod.fb$value[cod.fb$indicator == "landings"], "discards"= cod.fb$value[cod.fb$indicator == "discards"]) %>% t() 
colnames(fb_cod) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_cod,3), caption = "Single stock forecast for COD")
kable(round(fb_cod,3), caption = "FLBEIA STF for COD")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_cod / ss_cod, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_cod), 2:ncol(ss_cod), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")

# THe actual fbar average is 0.4153275 0.4153275/0.477 = 0.8707075
# Notes 

```

## ~ COD - intermediate year
```{r}
  runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.cod.int,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_cod <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_cod["F",] <- c(1.13, 0.477, 0,NA)
ss_cod["SSB",] <- c(1181, 1587, 2943,6078)
ss_cod["catches",] <- c(1351,1055, NA,NA)
ss_cod["landings",] <- c(1051, 0, NA,NA)
ss_cod["discards",] <- c(300, 0, NA,NA)

cod.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
cod.fb <- cod.flbeia %>% filter(stock == "cod.27.7e-k")
fb_cod <- data.frame("F" = cod.fb$value[cod.fb$indicator == "f"],"SSB" = cod.fb$value[cod.fb$indicator == "ssb"], "catches" = cod.fb$value[cod.fb$indicator == "catch"], "landings" = cod.fb$value[cod.fb$indicator == "landings"], "discards"= cod.fb$value[cod.fb$indicator == "discards"]) %>% t() 
colnames(fb_cod) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_cod,3), caption = "Single stock forecast for COD")
kable(round(fb_cod,3), caption = "FLBEIA STF for COD")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_cod / ss_cod, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_cod), 2:ncol(ss_cod), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")

# THe actual fbar average is 0.4153275 0.4153275/0.477 = 0.8707075
# Notes 

```


## ~ HAD
```{r}
runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.had,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)
  
## Compare to the single stock advice
ss_had <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_had["F",] <- c(0.41, 0.41, 0.353,NA)
ss_had["SSB",] <- c(34642, 66169, 71323,70434)
ss_had["catches",] <- c(11259,20274, 18382,NA)
ss_had["landings",] <- c(7656, 9190, 9770,NA)
ss_had["discards",] <- c(3603, 11084, 8612,NA)

had.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))
had.fb <- had.flbeia %>% filter(stock == "had.27.7b-k")
fb_had <- data.frame("F" = had.fb$value[had.fb$indicator == "f"],"SSB" = had.fb$value[had.fb$indicator == "ssb"], "catches" = had.fb$value[had.fb$indicator == "catch"], "landings" = had.fb$value[had.fb$indicator == "landings"], "discards"= had.fb$value[had.fb$indicator == "discards"]) %>% t() 
colnames(fb_had) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_had,3), caption = "Single stock forecast for HAD")
kable(round(fb_had,3), caption = "FLBEIA STF for HAD")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_had / ss_had, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_had), 2:ncol(ss_had), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")

# THe actual fbar average is 0.4153275 0.4153275/0.477 = 0.8707075

```


## ~ WHG 
```{r}
## We do a forecast with the catch from the single stock advice
#advice.cod <- advice

runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.whg,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_whg <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_whg["F",] <- c(0.36, 0.495, 0.268,NA)
ss_whg["SSB",] <- c(29290, 31034, 32108,6078)
ss_whg["catches",] <- c(6294,8772, 5261,NA)
ss_whg["landings",] <- c(5542, 6937, 4215,NA)
ss_whg["discards",] <- c(300, 1835, 1046,NA)


whg.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
whg.fb <- whg.flbeia %>% filter(stock == "whg.27.7b-ce-k")
fb_whg <- data.frame("F" = whg.fb$value[whg.fb$indicator == "f"],"SSB" = whg.fb$value[whg.fb$indicator == "ssb"], "catches" = whg.fb$value[whg.fb$indicator == "catch"], "landings" = whg.fb$value[whg.fb$indicator == "landings"], "discards"= whg.fb$value[whg.fb$indicator == "discards"]) %>% t() 
colnames(fb_whg) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_whg,3), caption = "Single stock forecast for WHG")
kable(round(fb_whg,3), caption = "FLBEIA STF for WHG")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_whg / ss_whg, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_whg), 2:ncol(ss_whg), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")
```


## ~ HKE
```{r}
## We do a forecast with the catch from the single stock advice
#advice.cod <- advice

runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.hke,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_hke <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_hke["F",] <- c(0.23,0.263, 0.26,NA)
ss_hke["SSB",] <- c(239829, 265202, 257712,249402)
ss_hke["catches",] <- c(87238,103027, 98657,NA)
ss_hke["landings",] <- c(82298, 97059, 92821,NA)
ss_hke["discards",] <- c(4940, 5968, 5835,NA)


hke.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
hke.fb <- hke.flbeia %>% filter(stock == "hke.27.3a46-8abd")
fb_hke <- data.frame("F" = hke.fb$value[hke.fb$indicator == "f"],"SSB" = hke.fb$value[hke.fb$indicator == "ssb"], "catches" = hke.fb$value[hke.fb$indicator == "catch"], "landings" = hke.fb$value[hke.fb$indicator == "landings"], "discards"= hke.fb$value[hke.fb$indicator == "discards"]) %>% t() 
colnames(fb_hke) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_hke,3), caption = "Single stock forecast for HKE")
kable(round(fb_hke,3), caption = "FLBEIA STF for HKE")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_hke / ss_hke, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_hke), 2:ncol(ss_hke), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")
```


## ~ MEG
just cnat get this to work! I Cant see what it is missing to cause this: 
[1] "meg.27.7b-k8abd"
Error in if ((Cr - sum(Cinf)) > 0) return(effort = 1e+100) : 
  missing value where TRUE/FALSE needed
```{r}
## We do a forecast with the catch from the single stock advice
#advice.cod <- advice

runs  <- FLBEIA(biols = biols,
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.meg,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_meg <- matrix(NA, ncol = 4, nrow = 5,
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"),
                                 year = c(2019:2022)))
ss_meg["F",] <- c(0.21, 0.21, 0.191,NA)
ss_meg["SSB",] <- c(111492, 429285, 111674,115734)
ss_meg["catches",] <- c(13153,20350, 19184,NA)
ss_meg["landings",] <- c(12164, 17201, 16454,NA)
ss_meg["discards",] <- c(989, 3149, 2730,NA)


meg.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))
meg.fb <- meg.flbeia %>% filter(stock == "meg.27.7b-k8abd")
fb_meg <- data.frame("F" = meg.fb$value[meg.fb$indicator == "f"],"SSB" = meg.fb$value[meg.fb$indicator == "ssb"], "catches" = meg.fb$value[meg.fb$indicator == "catch"], "landings" = meg.fb$value[meg.fb$indicator == "landings"], "discards"= meg.fb$value[meg.fb$indicator == "discards"]) %>% t()
colnames(fb_meg) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_meg,3), caption = "Single stock forecast for MEG")
kable(round(fb_meg,3), caption = "FLBEIA STF for MEG")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_meg / ss_meg, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_meg), 2:ncol(ss_meg), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")
```

## ~ MON
```{r}
## We do a forecast with the catch from the single stock advice
#advice.cod <- advice

runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.mon,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_mon <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_mon["F",] <- c(0.27, 0.22, 0.28,NA)
ss_mon["SSB",] <- c(63222, 68952, 72213,80416)
ss_mon["catches",] <- c(22710,24343, 34579,NA)
ss_mon["landings",] <- c(21266, 22863, 33100,NA)
ss_mon["discards",] <- c(1444, 1480, 1479,NA)


mon.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
mon.fb <- mon.flbeia %>% filter(stock == "mon.27.78abd")
fb_mon <- data.frame("F" = mon.fb$value[mon.fb$indicator == "f"],"SSB" = mon.fb$value[mon.fb$indicator == "ssb"], "catches" = mon.fb$value[mon.fb$indicator == "catch"], "landings" = mon.fb$value[mon.fb$indicator == "landings"], "discards"= mon.fb$value[mon.fb$indicator == "discards"]) %>% t() 
colnames(fb_mon) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_mon,3), caption = "Single stock forecast for MON")
kable(round(fb_mon,3), caption = "FLBEIA STF for MON")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_mon / ss_mon, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_mon), 2:ncol(ss_mon), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")
```

## ~ SOL
```{r}
## We do a forecast with the catch from the single stock advice
#advice.cod <- advice

runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.sol,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_sol <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_sol["F",] <- c(0.24, 0.296, 0.251,NA)
ss_sol["SSB",] <- c(5546, 6293, 6197,6009)
ss_sol["catches",] <- c(1213,1652, 1413,NA)
ss_sol["landings",] <- c(1068, 1529, 1308,NA)
ss_sol["discards",] <- c(145, 123, 105,NA)


sol.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
sol.fb <- sol.flbeia %>% filter(stock == "sol.27.7fg")
fb_sol <- data.frame("F" = sol.fb$value[sol.fb$indicator == "f"],"SSB" = sol.fb$value[sol.fb$indicator == "ssb"], "catches" = sol.fb$value[sol.fb$indicator == "catch"], "landings" = sol.fb$value[sol.fb$indicator == "landings"], "discards"= sol.fb$value[sol.fb$indicator == "discards"]) %>% t() 
colnames(fb_sol) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_sol,3), caption = "Single stock forecast for SOL")
kable(round(fb_sol,3), caption = "FLBEIA STF for SOL")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_sol / ss_sol, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_sol), 2:ncol(ss_sol), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")
```

## ~ NEP FU16
```{r, include = FALSE}
## We do a forecast with the catch from the single stock advice
#advice.cod <- advice

runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.sol,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_sol <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_sol["F",] <- c(0.32, 0.296, 0.251,NA)
ss_sol["SSB",] <- c(6541, 7907, 6197,6009)
ss_sol["catches",] <- c(1213,1652, 1413,NA)
ss_sol["landings",] <- c(1068, 1529, 1308,NA)
ss_sol["discards",] <- c(145, 123, 105,NA)


sol.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
sol.fb <- sol.flbeia %>% filter(stock == "sol.27.7fg")
fb_sol <- data.frame("F" = sol.fb$value[sol.fb$indicator == "f"],"SSB" = sol.fb$value[sol.fb$indicator == "ssb"], "catches" = sol.fb$value[sol.fb$indicator == "catch"], "landings" = sol.fb$value[sol.fb$indicator == "landings"], "discards"= sol.fb$value[sol.fb$indicator == "discards"]) %>% t() 
colnames(fb_sol) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_sol,3), caption = "Single stock forecast for SOL")
kable(round(fb_sol,3), caption = "FLBEIA STF for SOL")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_sol / ss_sol, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_sol), 2:ncol(ss_sol), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")
```

## ~ NEP FU17
```{r, include = FALSE}
## We do a forecast with the catch from the single stock advice
#advice.cod <- advice

runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.sol,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_sol <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_sol["F",] <- c(0.32, 0.296, 0.251,NA)
ss_sol["SSB",] <- c(6541, 7907, 6197,6009)
ss_sol["catches",] <- c(1213,1652, 1413,NA)
ss_sol["landings",] <- c(1068, 1529, 1308,NA)
ss_sol["discards",] <- c(145, 123, 105,NA)


sol.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
sol.fb <- sol.flbeia %>% filter(stock == "sol.27.7fg")
fb_sol <- data.frame("F" = sol.fb$value[sol.fb$indicator == "f"],"SSB" = sol.fb$value[sol.fb$indicator == "ssb"], "catches" = sol.fb$value[sol.fb$indicator == "catch"], "landings" = sol.fb$value[sol.fb$indicator == "landings"], "discards"= sol.fb$value[sol.fb$indicator == "discards"]) %>% t() 
colnames(fb_sol) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_sol,3), caption = "Single stock forecast for SOL")
kable(round(fb_sol,3), caption = "FLBEIA STF for SOL")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_sol / ss_sol, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_sol), 2:ncol(ss_sol), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")
```

## ~ NEP FU19
```{r,include = FALSE}
## We do a forecast with the catch from the single stock advice
#advice.cod <- advice

runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.sol,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_sol <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_sol["F",] <- c(0.32, 0.296, 0.251,NA)
ss_sol["SSB",] <- c(6541, 7907, 6197,6009)
ss_sol["catches",] <- c(1213,1652, 1413,NA)
ss_sol["landings",] <- c(1068, 1529, 1308,NA)
ss_sol["discards",] <- c(145, 123, 105,NA)


sol.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
sol.fb <- sol.flbeia %>% filter(stock == "sol.27.7fg")
fb_sol <- data.frame("F" = sol.fb$value[sol.fb$indicator == "f"],"SSB" = sol.fb$value[sol.fb$indicator == "ssb"], "catches" = sol.fb$value[sol.fb$indicator == "catch"], "landings" = sol.fb$value[sol.fb$indicator == "landings"], "discards"= sol.fb$value[sol.fb$indicator == "discards"]) %>% t() 
colnames(fb_sol) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_sol,3), caption = "Single stock forecast for SOL")
kable(round(fb_sol,3), caption = "FLBEIA STF for SOL")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_sol / ss_sol, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_sol), 2:ncol(ss_sol), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")
```

## ~ NEP FU2021
```{r, include = FALSE}
## We do a forecast with the catch from the single stock advice
#advice.cod <- advice

runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.sol,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_sol <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_sol["F",] <- c(0.32, 0.296, 0.251,NA)
ss_sol["SSB",] <- c(6541, 7907, 6197,6009)
ss_sol["catches",] <- c(1213,1652, 1413,NA)
ss_sol["landings",] <- c(1068, 1529, 1308,NA)
ss_sol["discards",] <- c(145, 123, 105,NA)


sol.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
sol.fb <- sol.flbeia %>% filter(stock == "sol.27.7fg")
fb_sol <- data.frame("F" = sol.fb$value[sol.fb$indicator == "f"],"SSB" = sol.fb$value[sol.fb$indicator == "ssb"], "catches" = sol.fb$value[sol.fb$indicator == "catch"], "landings" = sol.fb$value[sol.fb$indicator == "landings"], "discards"= sol.fb$value[sol.fb$indicator == "discards"]) %>% t() 
colnames(fb_sol) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_sol,3), caption = "Single stock forecast for SOL")
kable(round(fb_sol,3), caption = "FLBEIA STF for SOL")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_sol / ss_sol, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_sol), 2:ncol(ss_sol), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")
```

## ~ NEP FU22
```{r, include = FALSE}
## We do a forecast with the catch from the single stock advice
#advice.cod <- advice

runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.sol,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_sol <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_sol["F",] <- c(0.32, 0.296, 0.251,NA)
ss_sol["SSB",] <- c(6541, 7907, 6197,6009)
ss_sol["catches",] <- c(1213,1652, 1413,NA)
ss_sol["landings",] <- c(1068, 1529, 1308,NA)
ss_sol["discards",] <- c(145, 123, 105,NA)


sol.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
sol.fb <- sol.flbeia %>% filter(stock == "sol.27.7fg")
fb_sol <- data.frame("F" = sol.fb$value[sol.fb$indicator == "f"],"SSB" = sol.fb$value[sol.fb$indicator == "ssb"], "catches" = sol.fb$value[sol.fb$indicator == "catch"], "landings" = sol.fb$value[sol.fb$indicator == "landings"], "discards"= sol.fb$value[sol.fb$indicator == "discards"]) %>% t() 
colnames(fb_sol) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_sol,3), caption = "Single stock forecast for SOL")
kable(round(fb_sol,3), caption = "FLBEIA STF for SOL")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_sol / ss_sol, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_sol), 2:ncol(ss_sol), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")
```

## ~ NEP 7 OUTFU
```{r, include = FALSE}
## We do a forecast with the catch from the single stock advice
#advice.cod <- advice

runs  <- FLBEIA(biols = biols, 
              SRs = SRs,
              BDs = NULL,
              fleets = fleets,
              indices = NULL,
              advice = advice,
              covars = NULL,
              main.ctrl = main.ctrl,
              biols.ctrl = biols.ctrl,
              fleets.ctrl = fleets.ctrl.sol,
              covars.ctrl = NULL,
              obs.ctrl = obs.ctrl,
              assess.ctrl = assess.ctrl,
              advice.ctrl = advice.ctrl)

## Compare to the single stock advice
ss_sol <- matrix(NA, ncol = 4, nrow = 5, 
                 dimnames = list(metric = c("F", "SSB", "catches", "landings", "discards"), 
                                 year = c(2019:2022)))
ss_sol["F",] <- c(0.32, 0.296, 0.251,NA)
ss_sol["SSB",] <- c(6541, 7907, 6197,6009)
ss_sol["catches",] <- c(1213,1652, 1413,NA)
ss_sol["landings",] <- c(1068, 1529, 1308,NA)
ss_sol["discards",] <- c(145, 123, 105,NA)


sol.flbeia <- bioSum(runs , long = TRUE,years = ac(2019:2022))

## cod top up
sol.fb <- sol.flbeia %>% filter(stock == "sol.27.7fg")
fb_sol <- data.frame("F" = sol.fb$value[sol.fb$indicator == "f"],"SSB" = sol.fb$value[sol.fb$indicator == "ssb"], "catches" = sol.fb$value[sol.fb$indicator == "catch"], "landings" = sol.fb$value[sol.fb$indicator == "landings"], "discards"= sol.fb$value[sol.fb$indicator == "discards"]) %>% t() 
colnames(fb_sol) <- c(first.yr.sim-1, first.yr.sim:last.yr.sim)

kable(round(ss_sol,3), caption = "Single stock forecast for SOL")
kable(round(fb_sol,3), caption = "FLBEIA STF for SOL")

## relative difference, flbeia/ single-stock
## We use a huxtable to automatically highlight big differences

round(fb_sol / ss_sol, 3) %>%
  as_huxtable(add_colnames = TRUE, add_rownames = "Metric") %>%
  set_bold(1, everywhere, TRUE) %>%
  set_bold(everywhere, 1, TRUE) %>%
  set_bottom_border(1, everywhere, 2) %>%
  map_text_color(2:nrow(ss_sol), 2:ncol(ss_sol), by_ranges(c(0.9, 1.1), c("red", "black", "red"))) %>%
  set_caption("Relative difference between single stock and FLBEIA forecasts")
```

